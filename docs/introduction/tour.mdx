---
title: "The Grand Tour"
description: "A guided journey through BeeAI Framework‚Äôs modular architecture"
icon: "route"
---

This guide walks you step by step: you‚Äôll start by running your very first agent, then add new skills one at a time. By the end, you‚Äôll have a production-ready system that can scale, integrate, and coordinate with other agents.

Follow the whole path for the full tour, or jump into the stage you need most.

## Journey Overview

Here‚Äôs the roadmap from the most basic to the most advanced concepts:

<CardGroup cols={2}>
  <Card title="Foundation" icon="layer-group" href="#foundation">
    Your first simple chat agent using Agent and Backend modules
  </Card>

  <Card title="Observability" icon="eyes" href="#observability">
    Learn to see inside your agent with logs, traces, and metrics
  </Card>
  
  <Card title="Intelligence" icon="brain" href="#intelligence">
    Make your agent smarter with memory, tools, and prompt templates
  </Card>

  <Card title="Requirements" icon="check-circle" href="#requirements">  
    Add reasoning rules, guardrails, and user permissions
  </Card>
  
  <Card title="Knowledge" icon="book-open" href="#knowledge">
    Ground your agent in real data with RAG and document search
  </Card>
  
  <Card title="Orchestration" icon="sitemap" href="#orchestration">
    Coordinate teams of specialized agents with handoffs
  </Card>
  
  <Card title="Production" icon="gears" href="#production">
    Scale with caching, error handling, and reliability patterns
  </Card>
  
  <Card title="Integration" icon="server" href="#integration">
    Expose agents as services (MCP, BeeAI Platform, A2A, IBM wxO)
  </Card>
</CardGroup>

## Prerequisites

- **Python 3.11++**
- **BeeAI Framework**: `pip install beeai-framework`
- **Ollama** running locally: [Download Ollama](https://ollama.com/)
- **Model downloaded**: `ollama pull granite3.3:8b`

<Tip>
You can also use other LLM providers like OpenAI, Anthropic, or watsonx - see [Backend](https://framework.beeai.dev/modules/backend) to learn more about supported providers.
</Tip>

---

## Foundation

### Build Your First Agent

<Info>
**New Modules**: [Agent](https://framework.beeai.dev/modules/agents), [Backend](https://framework.beeai.dev/modules/backend)
</Info>

Start by creating the simplest possible agent. This example uses only the `Agent` and `Backend` modules to send a prompt and get a response.
    
```python
import asyncio
from beeai_framework.agents.experimental import RequirementAgent
from beeai_framework.backend import ChatModel

async def main():
    agent = RequirementAgent(
        llm=ChatModel.from_name("ollama:granite3.3:8b"),
        instructions="You are a friendly AI assistant. Be helpful and conversational."
    )

    response = await agent.run("Hello! What can you help me with?")
    print(response.last_message.text)

if __name__ == "__main__":
    asyncio.run(main())
```

**Try it:**

1. Save as `simple_agent.py`
2. Run: `python simple_agent.py`
3. Test different prompts

**Troubleshooting**

<AccordionGroup>
  <Accordion title="Ollama not responding?">
    Verify it's running: `ollama list`<br />
    Check the service: `ollama serve`
  </Accordion>

  <Accordion title="Model not found?">
    Pull the model: `ollama pull granite3.3:8b`<br />
    List available models: `ollama list`
  </Accordion>

  <Accordion title="Import errors?">
    Update your installation: `pip install --upgrade beeai-framework`<br />
    Check Python version: `python --version` (must be 3.11+)
  </Accordion>
</AccordionGroup>

---

## Observability

Understanding what your agent is doing is crucial from day one. The BeeAI Framework provides four complementary ways to observe your agents:

| **What** | **When to Use** | **What You Get** |
|:----------|:-----------------|:------------------|
| **Logger** | Application-level debugging | Human-readable timestamped messages |
| **Middleware** | Framework-level debugging | Visual execution flow |
| **Events + Emitter** | Custom reactions to agent behavior | Real-time programmatic event handling |
| **Observability** | Production monitoring | External platform integration (dashboards, metrics) |

Let's see each one in action...

### Logger

<Info>
**New Module**: [Logger](https://framework.beeai.dev/modules/logger)
</Info>

**Use this for**: When you want to log specific events in your application code

**How it works**: You manually write logging statements wherever you want them

```python
import asyncio
from beeai_framework.agents.experimental import RequirementAgent
from beeai_framework.backend import ChatModel
from beeai_framework.logger import Logger

async def main():
    # You create the logger and decide what to log
    logger = Logger("my-agent", level="TRACE")
    
    logger.info("Starting agent application")
    
    agent = RequirementAgent(
        llm=ChatModel.from_name("ollama:granite3.3:8b"),
        instructions="You are a helpful AI assistant."
    )

    logger.debug("About to process user message")
    response = await agent.run("Hello! What can you help me with today?")
    logger.info("Agent response generated")
    
    print(f"Agent: {response.last_message.text}")

if __name__ == "__main__":
    asyncio.run(main())
```

**What you see**: Traditional log messages with timestamps
```
2024-01-15 10:30:45 | INFO | my-agent - Starting agent application
2024-01-15 10:30:45 | DEBUG | my-agent - About to process user message  
2024-01-15 10:30:47 | INFO | my-agent - Agent response generated successfully
```

### Middleware

<Info>
**New Feature**: GlobalTrajectoryMiddleware (part of the framework's middleware system)
</Info>

**Use this for**: When you want to see what the framework is doing internally without writing any logging code

**How it works**: Framework automatically intercepts and displays all internal operations

```python
import asyncio
from beeai_framework.agents.experimental import RequirementAgent
from beeai_framework.backend import ChatModel
from beeai_framework.tools.search.wikipedia import WikipediaTool
from beeai_framework.tools.weather import OpenMeteoTool
from beeai_framework.middleware.trajectory import GlobalTrajectoryMiddleware
from beeai_framework.tools import Tool

async def main():
    agent = RequirementAgent(
        llm=ChatModel.from_name("ollama:granite3.3:8b"),
        tools=[WikipediaTool(), OpenMeteoTool()],
        instructions="You are a research assistant."
    )

    # Show visual execution flow - like a debugger trace
    response = await agent.run(
        "What's the weather in Paris and tell me about the Eiffel Tower?"
    ).middleware(GlobalTrajectoryMiddleware(included=[Tool]))
    
    print(f"\nFinal Response: {response.answer.text}")

if __name__ == "__main__":
    asyncio.run(main())
```

**What you see**: Visual execution tree showing exactly what your agent did
```
ü§ñ RequirementAgent[start]: processing user input
  üõ†Ô∏è OpenMeteoTool[start]: {"location": "Paris"}
  üõ†Ô∏è OpenMeteoTool[success]: {"temperature": "15¬∞C", "condition": "cloudy"}
  üõ†Ô∏è WikipediaTool[start]: {"query": "Eiffel Tower"}
  üõ†Ô∏è WikipediaTool[success]: {"summary": "The Eiffel Tower is..."}
ü§ñ RequirementAgent[success]: response generated
```

### Events + Emitter

<Info>
**New Modules**: [Events](https://framework.beeai.dev/modules/events), [Emitter](https://framework.beeai.dev/modules/emitter)
</Info>

**Use this for**: Building custom logic that reacts to agent events (like webhooks for your agent)

```python
import asyncio
from beeai_framework.agents.experimental import RequirementAgent
from beeai_framework.backend import ChatModel
from beeai_framework.tools.weather import OpenMeteoTool

async def main():
    agent = RequirementAgent(
        llm=ChatModel.from_name("ollama:granite3.3:8b"),
        tools=[OpenMeteoTool()],
        instructions="You provide weather information."
    )

    # Set up custom event handlers - like event listeners in JavaScript
    def track_tool_usage(data, event):
        if event.name == "tool_start":
            print(f"üîß Starting tool: {data.get('tool_name', 'unknown')}")
        elif event.name == "tool_success":
            print(f"‚úÖ Tool completed successfully")
        elif event.name == "error":
            print(f"‚ùå Error occurred: {data}")

    # Listen to all agent events and react accordingly
    response = await agent.run("What's the weather in Tokyo?").on("*", track_tool_usage)
    
    print(f"Final answer: {response.last_message.text}")

if __name__ == "__main__":
    asyncio.run(main())
```

**What you see**: Custom reactions to events as they happen
```
üîß Starting tool: OpenMeteoTool
‚úÖ Tool completed successfully
Final answer: The weather in Tokyo is currently...
```

### Production Monitoring

<Info>
**New Module**: [Observability](https://framework.beeai.dev/modules/observability)
</Info>

**Use this for**: Production monitoring with external platforms (Arize Phoenix, LangFuse, LangSmith)

```python
import asyncio
from beeai_framework.agents.experimental import RequirementAgent
from beeai_framework.backend import ChatModel
from beeai_framework.tools.weather import OpenMeteoTool

# Enable OpenTelemetry tracing (do this once at app startup)
from openinference.instrumentation.beeai import BeeAIInstrumentor
from opentelemetry import trace as trace_api
from opentelemetry.exporter.otlp.proto.http.trace_exporter import OTLPSpanExporter
from opentelemetry.sdk import trace as trace_sdk
from opentelemetry.sdk.trace.export import SimpleSpanProcessor

def setup_production_monitoring():
    tracer_provider = trace_sdk.TracerProvider()
    tracer_provider.add_span_processor(SimpleSpanProcessor(OTLPSpanExporter()))
    trace_api.set_tracer_provider(tracer_provider)
    BeeAIInstrumentor().instrument()

async def main():
    # Enable production monitoring
    setup_production_monitoring()
    
    # Your agent runs normally - monitoring happens automatically
    agent = RequirementAgent(
        llm=ChatModel.from_name("ollama:granite3.3:8b"),
        tools=[OpenMeteoTool()],
        instructions="You provide weather information."
    )

    response = await agent.run("What's the weather in London?")
    print(response.last_message.text)
    
    # All traces are automatically sent to your monitoring platform

if __name__ == "__main__":
    asyncio.run(main())
```

**What you get**: Traces and metrics in external monitoring platforms like Arize Phoenix or LangFuse for production analytics.

In practice, you'll often use multiple approaches together.


---

## Intelligence

Now it's time to add capabilities to your agent.

### Memory Management Strategies

<Info>
New Module: [Memory](https://framework.beeai.dev/modules/memory)
</Info>

While the agent comes with memory by default, you can customize how it manages conversation history:

```python
import asyncio
from beeai_framework.agents.experimental import RequirementAgent
from beeai_framework.backend import ChatModel
from beeai_framework.memory import UnconstrainedMemory, SlidingMemory, TokenMemory

async def main():
    # Different memory strategies
    
    # 1. Unconstrained Memory (default) - remembers everything
    agent_unlimited = RequirementAgent(
        llm=ChatModel.from_name("ollama:granite3.3:8b"),
        memory=UnconstrainedMemory()
    )
    
    # 2. Sliding Memory - keeps only recent messages
    agent_sliding = RequirementAgent(
        llm=ChatModel.from_name("ollama:granite3.3:8b"),
        memory=SlidingMemory(SlidingMemoryConfig(size=10))
    )
    
    # 3. Token Memory - manages memory based on token count
    agent_token = RequirementAgent(
        llm=ChatModel.from_name("ollama:granite3.3:8b"),
        memory=TokenMemory(max_tokens=2000,llm=ChatModel.from_name("ollama:granite3.3:8b")),  # Keep conversation under 2000 tokens
    )
    
    # Test different memory strategies
    long_conversation = [
        "My name is Alice and I'm 25 years old.",
        "I work as a software engineer in San Francisco.",
        "I love hiking and photography in my free time.",
        "My favorite programming language is Python.",
        "I'm currently learning about AI and machine learning."
    ]
    
    # Test with sliding memory
    print("=== Testing Sliding Memory ===")
    for message in long_conversation:
        response = await agent_sliding.run(message)
        print(f"User: {message}")
        print(f"Agent: {response.answer.text}\n")
    
    # Ask about early conversation - sliding memory might forget
    response = await agent_sliding.run("What's my name and age?")
    print(f"Final test - User: What's my name and age?")
    print(f"Agent: {response.answer.text}")

if __name__ == "__main__":
    asyncio.run(main())
```

**Test memory retention**

1. Compare how different memory strategies handle long conversations
2. Test what happens when memory limits are reached
3. Observe how agents behave when they "forget" early parts of conversations

### Tools for External Capabilities

<Info>
New Module: [Tools](https://framework.beeai.dev/modules/tools)
</Info>

Give your agent the ability to access real-world information:

```python
import asyncio
from beeai_framework.agents.experimental import RequirementAgent
from beeai_framework.backend import ChatModel
from beeai_framework.tools.search.wikipedia import WikipediaTool
from beeai_framework.tools.weather import OpenMeteoTool

async def main():
    # Enhanced agent with tools
    agent = RequirementAgent(
        llm=ChatModel.from_name("ollama:granite3.3:8b"),
        tools=[WikipediaTool(), OpenMeteoTool()],
        instructions="You are a helpful research assistant. Use your tools to find accurate, current information."
    )

    # Test the tools
    response = await agent.run("What's the current weather in New York and tell me about the history of the city?")
    print(response.last_message.text)

if __name__ == "__main__":
    asyncio.run(main())
```

Try these prompts:
- "What's the weather in different cities around the world?"
- "Tell me about quantum computing and the current weather in CERN's location"
- "Compare the weather in New York and London, then tell me about their historical relationship"

### Prompt Templates

<Info>
New Module: [Templates](https://framework.beeai.dev/modules/templates)
</Info>

Create reusable, type-safe prompt templates using Mustache syntax:

```python
import asyncio
from beeai_framework.agents.experimental import RequirementAgent
from beeai_framework.backend import ChatModel
from beeai_framework.template import PromptTemplate
from pydantic import BaseModel

class MessageSchema(BaseModel):
    user_name: str
    task: str
    
# Create a custom template for agent instructions
instruction_template = PromptTemplate(
    schema=MessageSchema,
    template="""You are an AI assistant helping {{user_name}}. 
Your current task is: {{task}}

Be helpful, accurate, and concise in your responses.""",
    defaults={"user_name": "User"}
)

async def main():
    # Render the template with specific data
    custom_instructions = instruction_template.render(
        user_name="Alice",
        task="analyzing financial reports"
    )
    
    agent = RequirementAgent(
        llm=ChatModel.from_name("ollama:granite3.3:8b"),
        instructions=custom_instructions
    )
    
    response = await agent.run("What should I look for in quarterly earnings?")
    print(response.last_message.text)

if __name__ == "__main__":
    asyncio.run(main())
```

---

## Requirements

### Add Reasoning

Control how your agent thinks and acts using Requirements:

```python
import asyncio
from beeai_framework.agents.experimental import RequirementAgent
from beeai_framework.agents.experimental.requirements.conditional import ConditionalRequirement
from beeai_framework.backend import ChatModel
from beeai_framework.tools.search.wikipedia import WikipediaTool
from beeai_framework.tools.weather import OpenMeteoTool
from beeai_framework.tools.think import ThinkTool
from beeai_framework.tools import Tool
from beeai_framework.middleware.trajectory import GlobalTrajectoryMiddleware
from beeai_framework.logger import Logger

# Configure logging to show thinking process
logger = Logger("agent", level="DEBUG")

async def main():
    # Create a ReAct agent (Reasoning + Acting)
    agent = RequirementAgent(
        llm=ChatModel.from_name("ollama:granite3.3:8b"),
        tools=[ThinkTool(), WikipediaTool(), OpenMeteoTool()],
        requirements=[
            # Force agent to think before acting, and after each tool use
            ConditionalRequirement(
                ThinkTool, 
                force_at_step=1,  # Always think first
                force_after=Tool,  # Think after using any tool
                consecutive_allowed=False  # Don't think twice in a row
            )
        ],
        instructions="You are a methodical research assistant. Always think through problems step by step."
        # Add middleware to log tool executions including thinking
        middlewares=[GlobalTrajectoryMiddleware(included=[Tool])]
    )
    
    response = await agent.run("I'm planning a trip to Paris next month. Help me understand what to expect.")
    print(response.last_message.text)

if __name__ == "__main__":
    asyncio.run(main())
```

<Tip>
Learn more about Requirements and see examples at [Requirement Agent Documentation](https://framework.beeai.dev/experimental/requirement-agent)
</Tip>

### Ask for Permission

Here is how to add user permission for sensitive operations:

```python
import asyncio
from beeai_framework.agents.experimental import RequirementAgent
from beeai_framework.agents.experimental.requirements.ask_permission import AskPermissionRequirement
from beeai_framework.backend import ChatModel
from beeai_framework.tools.weather import OpenMeteoTool

async def main():
    # Agent that asks permission before using weather tool
    agent = RequirementAgent(
        llm=ChatModel.from_name("ollama:granite3.3:8b"),
        tools=[OpenMeteoTool()],
        requirements=[
            AskPermissionRequirement([OpenMeteoTool])  # Ask before using weather API
        ],
        instructions="You provide weather information, but ask permission first."
    )
    
    response = await agent.run("What's the weather in Tokyo?")
    print(response.last_message.text)

if __name__ == "__main__":
    asyncio.run(main())
```

---

## Knowledge

Now it's time to integrate external data.

<Info>
New Module: [RAG](https://framework.beeai.dev/modules/rag)
</Info>

Let's give your agent access to a knowledge base of documents. We'll split this into manageable steps:

### Setup the Vector Store

```python
import asyncio
from beeai_framework.backend.document_loader import DocumentLoader
from beeai_framework.backend.embedding import EmbeddingModel
from beeai_framework.backend.text_splitter import TextSplitter
from beeai_framework.backend.vector_store import VectorStore

async def setup_knowledge_base():
    # Create embedding model using Ollama
    embedding_model = EmbeddingModel.from_name("ollama:nomic-embed-text")
    
    # Create vector store
    vector_store = VectorStore.from_name(
        "beeai:TemporalVectorStore", 
        embedding_model=embedding_model
    )
    
    # Setup text splitter for chunking documents
    text_splitter = TextSplitter.from_name(
        "langchain:RecursiveCharacterTextSplitter", 
        chunk_size=1000, 
        chunk_overlap=200
    )
    
    return vector_store, text_splitter

async def load_documents(vector_store, text_splitter, file_paths):
    """Load documents into the vector store"""
    all_chunks = []
    
    for file_path in file_paths:
        try:
            # Load the document
            loader = DocumentLoader.from_name(
                "langchain:UnstructuredMarkdownLoader", 
                file_path=file_path
            )
            documents = await loader.load()
            
            # Split into chunks
            chunks = await text_splitter.split_documents(documents)
            all_chunks.extend(chunks)
            print(f"Loaded {len(chunks)} chunks from {file_path}")
        except Exception as e:
            print(f"Failed to load {file_path}: {e}")
    
    # Add all chunks to vector store
    if all_chunks:
        await vector_store.add_documents(all_chunks)
        print(f"Total chunks added: {len(all_chunks)}")
    
    return vector_store if all_chunks else None

async def main():
    # Setup the knowledge base
    vector_store, text_splitter = await setup_knowledge_base()
    
    # Replace with your actual markdown files
    file_paths = [
        "your_document1.md",
        "your_document2.md", 
    ]
    
    # Load documents
    loaded_vector_store = await load_documents(vector_store, text_splitter, file_paths)
    
    if loaded_vector_store:
        print("Knowledge base ready!")
        return loaded_vector_store
    else:
        print("No documents loaded")
        return None

if __name__ == "__main__":
    # Run this first to setup your knowledge base
    asyncio.run(main())
```

### Create RAG-Enabled Agent

```python
import asyncio
from beeai_framework.agents.experimental import RequirementAgent
from beeai_framework.backend import ChatModel
from beeai_framework.tools.search.wikipedia import WikipediaTool
from beeai_framework.tools.weather import OpenMeteoTool
from beeai_framework.tools.search.retrieval import VectorStoreSearchTool

# Import the setup function from Step 1
from step1_knowledge_base import setup_knowledge_base, load_documents

async def main():
    # Setup knowledge base (from Step 1)
    vector_store, text_splitter = await setup_knowledge_base()
    
    # Load your documents
    file_paths = [
        "your_document1.md",
        "your_document2.md", 
    ]
    
    loaded_vector_store = await load_documents(vector_store, text_splitter, file_paths)
    
    if not loaded_vector_store:
        print("No documents loaded - exiting")
        return
    
    # Create RAG tool
    rag_tool = VectorStoreSearchTool(vector_store=loaded_vector_store)

    # Create agent with RAG capabilities
    agent = RequirementAgent(
        llm=ChatModel.from_name("ollama:granite3.3:8b"),
        tools=[WikipediaTool(), OpenMeteoTool(), rag_tool],
        instructions="""You are a knowledgeable assistant with access to:
        1. A document knowledge base (use VectorStoreSearch for specific document queries)
        2. Wikipedia for general facts
        3. Weather information
        
        When users ask about topics that might be in the documents, search your knowledge base first."""
    )
    
    # Test the RAG-enabled agent
    response = await agent.run("What information do you have in your knowledge base?")
    print(response.last_message.text)

if __name__ == "__main__":
    asyncio.run(main())
```

1. Add some markdown files with information about your company/project
2. Ask questions that should be answered from your documents
3. Compare how responses differ with vs. without the knowledge base

<Note>
Install the RAG extras if you haven't already: `pip install 'beeai-framework[rag]'`
</Note>

## Orchestration

<Info>
New Module: [Workflows](https://framework.beeai.dev/modules/workflows)
</Info>

### Multi-Agent Hand-offs

Create a team of specialized agents that can collaborate:

```python
import asyncio
from beeai_framework.agents.experimental import RequirementAgent
from beeai_framework.backend import ChatModel
from beeai_framework.memory import UnconstrainedMemory
from beeai_framework.tools.search.wikipedia import WikipediaTool
from beeai_framework.tools.weather import OpenMeteoTool
from beeai_framework.tools.handoff import HandoffTool
from beeai_framework.tools.think import ThinkTool
from beeai_framework.logger import Logger

async def main():
    # Initialize logger
    logger = Logger("multi-agent-system", level="TRACE")
    logger.info("Starting multi-agent system")
    
    # Create specialized agents
    logger.debug("Creating knowledge agent")
    knowledge_agent = RequirementAgent(
        llm=ChatModel.from_name("ollama:granite3.3:8b"),
        tools=[ThinkTool(), WikipediaTool()],
        memory=UnconstrainedMemory(),
        instructions="Provide detailed, accurate information using available knowledge sources. Think through problems step by step."
    )
    
    logger.debug("Creating weather agent")
    weather_agent = RequirementAgent(
        llm=ChatModel.from_name("ollama:granite3.3:8b"),
        tools=[ThinkTool(), OpenMeteoTool()],
        memory=UnconstrainedMemory(),
        instructions="Provide comprehensive weather information and forecasts. Always think before using tools."
    )
    
    # Create a coordinator agent that manages handoffs
    logger.debug("Creating coordinator agent")
    coordinator_agent = RequirementAgent(
        llm=ChatModel.from_name("ollama:granite3.3:8b"),
        memory=UnconstrainedMemory(),
        tools=[
            HandoffTool(
                target=knowledge_agent, 
                name="knowledge_specialist", 
                description="For general knowledge and research questions"
            ),
            HandoffTool(
                target=weather_agent, 
                name="weather_expert", 
                description="For weather-related queries"
            ),
        ],
        instructions="""You coordinate between specialist agents. 
        - For weather queries: use weather_expert
        - For research/knowledge questions: use knowledge_specialist  
        - For mixed queries: break them down and use multiple specialists
        
        Always introduce yourself and explain which specialist will help."""
    )
    
    logger.info("Running query: What's the weather in Paris and tell me about its history?")
    try:
        response = await coordinator_agent.run("What's the weather in Paris and tell me about its history?")
        logger.info("Query completed successfully")
        print(response.last_message.text)
    except Exception as e:
        logger.error(f"Error during agent execution: {e}")
        raise
    
    logger.info("Multi-agent system execution completed")

if __name__ == "__main__":
    asyncio.run(main())
```

1. Ask the coordinator mixed questions: "What's the weather in Paris and tell me about its history?"
2. Test how it decides which agent to use
3. Try complex queries that need multiple specialists

### Advanced Workflows

For complex, multi-step processes, a more advanced workflow system is coming soon!

<Info>
Learn more: https://github.com/i-am-bee/beeai-framework/discussions/1005
</Info>

---

## Production

Now it's time for production-grade features.

### Intelligent Caching System

<Info>
New Module: [Cache](https://framework.beeai.dev/modules/cache)
</Info>

Speed up responses and reduce costs with smart caching:

```python
import asyncio
from beeai_framework.agents.experimental import RequirementAgent
from beeai_framework.backend import ChatModel
from beeai_framework.memory import UnconstrainedMemory
from beeai_framework.tools.weather import OpenMeteoTool
from beeai_framework.cache import UnconstrainedCache

async def main():
    # Create a cached weather tool to avoid repeated API calls
    weather_tool = OpenMeteoTool(options={"cache": UnconstrainedCache()})
    
    agent = RequirementAgent(
        llm=ChatModel.from_name("ollama:granite3.3:8b"),
        memory=UnconstrainedMemory(),
        tools=[weather_tool],
        instructions="You provide weather information efficiently."
    )

    # First call will hit the API
    response1 = await agent.run("What's the weather in New York?")
    print("First call:", response1.answer.text)
    
    # Second call will use cached result
    response2 = await agent.run("What's the weather in New York?")
    print("Cached call:", response2.answer.text)

if __name__ == "__main__":
    asyncio.run(main())
```

### Error Handling

<Info>
New Module: [Errors](https://framework.beeai.dev/modules/errors)
</Info>

Make your system robust with comprehensive error management:

```python
import asyncio
import traceback
from beeai_framework.agents.experimental import RequirementAgent
from beeai_framework.backend import ChatModel
from beeai_framework.memory import UnconstrainedMemory
from beeai_framework.tools.weather import OpenMeteoTool
from beeai_framework.errors import FrameworkError

async def main():
    try:
        agent = RequirementAgent(
            llm=ChatModel.from_name("ollama:granite3.3:8b"),
            memory=UnconstrainedMemory(),
            tools=[OpenMeteoTool()],
            instructions="You provide weather information."
        )

        response = await agent.run("What's the weather in Invalid-City-Name?")
        print(response.last_message.text)
        
    except FrameworkError as e:
        print(f"Framework error occurred: {e.explain()}")
        traceback.print_exc()
    except Exception as e:
        print(f"Unexpected error: {e}")
        traceback.print_exc()

if __name__ == "__main__":
    asyncio.run(main())
```

---

## Integration

<Info>
New Module: [Serve](https://framework.beeai.dev/modules/serve)
</Info>

### Model Context Protocol (MCP)

Expose your agent as an **MCP server**:
    
```python
from beeai_framework.adapters.mcp import MCPServer
from beeai_framework.tools.weather import OpenMeteoTool
from beeai_framework.tools.search.wikipedia import WikipediaTool

def main():
    # Create an MCP server
    server = MCPServer()
    
    # Register tools that can be used by MCP clients
    server.register_many([
        OpenMeteoTool(),
        WikipediaTool()
    ])
    
    # Start the server
    server.serve()

if __name__ == "__main__":
    main()
```

### BeeAI Platform

Expose your agent as a **BeeAI Platform server**:
    
```python
from beeai_framework.adapters.beeai_platform.serve.server import BeeAIPlatformServer
from beeai_framework.agents.experimental import RequirementAgent
from beeai_framework.backend import ChatModel
from beeai_framework.memory import UnconstrainedMemory
from beeai_framework.middleware.trajectory import GlobalTrajectoryMiddleware
from beeai_framework.tools.search.wikipedia import WikipediaTool
from beeai_framework.tools.weather import OpenMeteoTool

def main():
    llm = ChatModel.from_name("ollama:granite3.3:8b")
    agent = RequirementAgent(
        llm=llm,
        tools=[WikipediaTool(), OpenMeteoTool()],
        memory=UnconstrainedMemory(),
        middlewares=[GlobalTrajectoryMiddleware()],
        instructions="You are a helpful research assistant with access to Wikipedia and weather data."
    )

    # Runs HTTP server that registers to BeeAI platform
    server = BeeAIPlatformServer()
    server.register(agent)
    server.serve()

if __name__ == "__main__":
    main()
```

### Agent2Agent (A2A) Protocol

Expose your agent as an **A2A server**:
    
```python
from beeai_framework.adapters.a2a import A2AServer, A2AServerConfig
from beeai_framework.agents.experimental import RequirementAgent
from beeai_framework.backend import ChatModel
from beeai_framework.memory import UnconstrainedMemory
from beeai_framework.serve.utils import LRUMemoryManager
from beeai_framework.tools.search.duckduckgo import DuckDuckGoSearchTool
from beeai_framework.tools.weather import OpenMeteoTool


def main() -> None:
    llm = ChatModel.from_name("ollama:granite3.3:8b")
    agent = RequirementAgent(
        llm=llm,
        tools=[DuckDuckGoSearchTool(), OpenMeteoTool()],
        memory=UnconstrainedMemory(),
    )

    # Register the agent with the A2A server and run the HTTP server
    # we use LRU memory manager to keep limited amount of sessions in the memory
    A2AServer(config=A2AServerConfig(port=9999), memory_manager=LRUMemoryManager(maxsize=100)).register(agent).serve()


if __name__ == "__main__":
    main()
```
  
### IBM watsonx Orchestrate

Expose your agent as an **IBM watsonx Orchestrate server**:
    
```python
from beeai_framework.adapters.watsonx_orchestrate import WatsonxOrchestrateServer, WatsonxOrchestrateServerConfig
from beeai_framework.agents.experimental import RequirementAgent
from beeai_framework.backend import ChatModel
from beeai_framework.memory import UnconstrainedMemory
from beeai_framework.serve.utils import LRUMemoryManager
from beeai_framework.tools.weather import OpenMeteoTool

def main() -> None:
    llm = ChatModel.from_name("ollama:granite3.3:8b")
    agent = RequirementAgent(
        llm=llm, 
        tools=[OpenMeteoTool()], 
        memory=UnconstrainedMemory(), 
        instructions="You are a weather agent that provides accurate weather information."
    )

    config = WatsonxOrchestrateServerConfig(port=8080, host="0.0.0.0", api_key=None)  # optional
    # use LRU memory manager to keep limited amount of sessions in the memory
    server = WatsonxOrchestrateServer(config=config, memory_manager=LRUMemoryManager(maxsize=100))
    server.register(agent)

    # start an API with /chat/completions endpoint which is compatible with Watsonx Orchestrate
    server.serve()


if __name__ == "__main__":
    main()
```

---

## What's Next?

Congratulations! You've built a complete AI agent system from a simple chat bot to a production-ready, multi-agent workflow with knowledge bases, caching, error handling, and service endpoints.

Each module page includes detailed guides, examples, and best practices. Here are some next steps:
1. **Explore Modules:** Dive deeper into specific modules that interest you
2. **Scale Your System:** Add more agents, tools, and knowledge bases
3. **Custom Tools:** Build your own tools for domain-specific functionality

The framework is designed to scale with you‚Äîstart small, then grow your system step by step as your needs evolve. You now have all the building blocks to create sophisticated AI agent systems!
