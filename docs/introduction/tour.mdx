---
title: "The Grand Tour"
description: "A guided journey through BeeAI Framework’s modular architecture"
icon: "route"
---

## Welcome to the Grand Tour

You’ve tried the quickstart and run some sample code—now it’s time to build something real.

This guide takes you step by step from your first agent to a production-ready system. Each section adds one new capability, so by the end you’ll see how everything fits together. You can follow the whole journey or skip ahead to the parts you need.

## Journey Overview

Here’s a quick map of the stages and modules:

<CardGroup cols={2}>
  <Card title="Foundation" icon="layer-group" href="#foundation">
    Your first simple chat agent using Agent and Backend modules
  </Card>
  
  <Card title="Intelligence" icon="brain" href="#intelligence">
    Add memory, tools, and templates for smarter agents
  </Card>
  
  <Card title="Knowledge" icon="book-open" href="#knowledge">
    Ground your agent in data with RAG capabilities
  </Card>
  
  <Card title="Orchestration" icon="sitemap" href="#orchestration">
    Coordinate teams of specialized agents with Workflows
  </Card>
  
  <Card title="Production" icon="gears" href="#production">
    Scale with caching, monitoring, and error handling
  </Card>
  
  <Card title="Integration" icon="server" href="#integration">
    Expose agents as services (MCP, BeeAI Platform, A2A, IBM watsonx Orchestrate)
  </Card>
</CardGroup>

## Prerequisites

- **Python 3.11+** installed
- **BeeAI Framework**: `pip install beeai-framework`  
- **Ollama** running locally: [Download Ollama](https://ollama.com/)
- **Model downloaded**: `ollama pull granite3.3:8b`

<Tip>
You can also use other LLM providers like OpenAI, Anthropic, or watsonx - see [Backend](https://framework.beeai.dev/modules/backend) to learn more about supported providers.
</Tip>

---

## Foundation: Build Your First Agent

### The Basics

<Info>
**New Modules**: [Agent](https://framework.beeai.dev/modules/agents), [Backend](https://framework.beeai.dev/modules/backend)
</Info>

Let's start with the simplest possible agent - one that can respond to messages.
    
```python
import asyncio
from beeai_framework.agents.experimental import RequirementAgent
from beeai_framework.backend import ChatModel

async def main():
    # Create your first agent
    agent = RequirementAgent(
        llm=ChatModel.from_name("ollama:granite3.3:8b"),
        role="Helpful Assistant",
        instructions="You are a friendly AI assistant. Be helpful and conversational."
    )

    # Talk to your agent
    response = await agent.run("Hello! Can you help me?")
    print(response.answer.text)

if __name__ == "__main__":
    asyncio.run(main())
```

**Test and experiment**

1. Run the code and send your first message
2. Experiment with different prompts to see the responses
3. Adjust the `role` and `instructions` to change behavior
4. Notice: The agent forgets everything between runs

**Troubleshooting**

<AccordionGroup>
  <Accordion title="Ollama not responding?">
    Verify it's running: `ollama list`<br />
    Check the service: `ollama serve`
  </Accordion>

  <Accordion title="Model not found?">
    Pull the model: `ollama pull granite3.3:8b`<br />
    List available models: `ollama list`
  </Accordion>

  <Accordion title="Import errors?">
    Update your installation: `pip install --upgrade` beeai-framework<br />
    Check Python version: `python --version` (must be 3.11+)
  </Accordion>
</AccordionGroup>

---

## Intelligence: Add Capabilities

### Memory for Conversations

<Info>
New Module: [Memory](https://framework.beeai.dev/modules/memory)
</Info>

Right now your agent forgets everything between conversations. Let's fix that:

```Python
import asyncio
from beeai_framework.agents.experimental import RequirementAgent
from beeai_framework.backend import ChatModel
from beeai_framework.memory import UnconstrainedMemory

async def main():
    # Add memory to remember the conversation
    agent = RequirementAgent(
        llm=ChatModel.from_name("ollama:granite3.3:8b"),
        memory=UnconstrainedMemory(),  # Remembers everything
        role="Helpful Assistant",
        instructions="You are a friendly AI assistant with a good memory."
    )

    # Now have a multi-turn conversation
    response1 = await agent.run("My name is Bob")
    print(response1.answer.text)
    
    response2 = await agent.run("What's my name?")  # It will remember!
    print(response2.answer.text)

if __name__ == "__main__":
    asyncio.run(main())
```

**Test memory retention**

1. Test the memory - introduce yourself, then ask follow-up questions
2. Have a long conversation and see how context is maintained
3. Ask the agent to reference previous parts of the conversation

### Tools for External Capabilities

<Info>
New Module: [Tools](https://framework.beeai.dev/modules/tools)
</Info>

Give your agent the ability to access real-world information:

```python
import asyncio
from beeai_framework.agents.experimental import RequirementAgent
from beeai_framework.backend import ChatModel
from beeai_framework.memory import UnconstrainedMemory
from beeai_framework.tools.search.wikipedia import WikipediaTool
from beeai_framework.tools.weather import OpenMeteoTool

async def main():
    # Enhanced agent with tools
    agent = RequirementAgent(
        llm=ChatModel.from_name("ollama:granite3.3:8b"),
        memory=UnconstrainedMemory(),
        tools=[WikipediaTool(), OpenMeteoTool()],  # Now it can search and get weather
        role="Research Assistant",
        instructions="You are a helpful research assistant. Use your tools to find accurate, current information."
    )

    # Test the tools
    response = await agent.run("What's the current weather in New York and tell me about the history of the city?")
    print(response.answer.text)

if __name__ == "__main__":
    asyncio.run(main())
```

Try these prompts:
- "What's the weather in different cities around the world?"
- "Tell me about quantum computing and the current weather in CERN's location"
- "Compare the weather in New York and London, then tell me about their historical relationship"

### Reasoning with Requirements

Control how your agent thinks and acts using Requirements:

```python
import asyncio
from beeai_framework.agents.experimental import RequirementAgent
from beeai_framework.agents.experimental.requirements.conditional import ConditionalRequirement
from beeai_framework.backend import ChatModel
from beeai_framework.memory import UnconstrainedMemory
from beeai_framework.tools.search.wikipedia import WikipediaTool
from beeai_framework.tools.weather import OpenMeteoTool
from beeai_framework.tools.think import ThinkTool
from beeai_framework.tools import Tool

async def main():
    # Create a ReAct agent (Reasoning + Acting)
    agent = RequirementAgent(
        llm=ChatModel.from_name("ollama:granite3.3:8b"),
        memory=UnconstrainedMemory(),
        tools=[ThinkTool(), WikipediaTool(), OpenMeteoTool()],
        requirements=[
            # Force agent to think before acting, and after each tool use
            ConditionalRequirement(
                ThinkTool, 
                force_at_step=1,  # Always think first
                force_after=Tool,  # Think after using any tool
                consecutive_allowed=False  # Don't think twice in a row
            )
        ],
        role="Analytical Research Assistant",
        instructions="You are a methodical research assistant. Always think through problems step by step."
    )
    
    response = await agent.run("I'm planning a trip to Paris next month. Help me understand what to expect.")
    print(response.answer.text)

if __name__ == "__main__":
    asyncio.run(main())
```

### Dynamic Prompt Templates

<Info>
New Module: [Templates](https://framework.beeai.dev/modules/templates)
</Info>

Instead of hardcoding instructions, let's use dynamic templates:

```Python
import asyncio
from beeai_framework.agents.experimental import RequirementAgent
from beeai_framework.backend import ChatModel
from beeai_framework.memory import UnconstrainedMemory
from beeai_framework.tools.search.wikipedia import WikipediaTool
from beeai_framework.tools.weather import OpenMeteoTool
from beeai_framework.template import PromptTemplate, PromptTemplateInput
from pydantic import BaseModel

class AgentInstructions(BaseModel):
    role: str
    domain: str
    context: str
    guidelines: list[str]
    personality: str

async def main():
    # Create a dynamic template
    template = PromptTemplate(
        PromptTemplateInput(
            schema=AgentInstructions,
            template="""You are {{role}} with expertise in {{domain}}.

Current context: {{context}}

Guidelines:
{{#guidelines}}
- {{.}}
{{/guidelines}}

Remember: Always be {{personality}} and use your available tools when needed.""",
            defaults={"personality": "helpful"}
        )
    )

    # Configure your agent dynamically
    instructions = template.render(
        role="Research Analyst",
        domain="technology and science",
        context="The user is looking for detailed, accurate information",
        guidelines=[
            "Verify facts with reliable sources",
            "Provide specific examples when possible", 
            "Cite your sources"
        ],
        personality="thorough and professional"
    )

    agent = RequirementAgent(
        llm=ChatModel.from_name("ollama:granite3.3:8b"),
        memory=UnconstrainedMemory(),
        tools=[WikipediaTool(), OpenMeteoTool()],
        instructions=instructions,
        role="Research Analyst"
    )
    
    response = await agent.run("Tell me about quantum computing")
    print(response.answer.text)

if __name__ == "__main__":
    asyncio.run(main())
```

**Experiment with different personalities**

1. Create a "Technical Expert" focused on programming and engineering
2. Try a "Creative Writer" with emphasis on storytelling and imagination
3. Build a "Data Analyst" that focuses on numbers and trends

---

## Knowledge: Integrate External Data

<Info>
New Module: [RAG](https://framework.beeai.dev/modules/rag)
</Info>

### Setup Knowledge Base

Let's give your agent access to a knowledge base of documents:

```Python
import asyncio
from beeai_framework.agents.experimental import RequirementAgent
from beeai_framework.backend import ChatModel
from beeai_framework.backend.document_loader import DocumentLoader
from beeai_framework.backend.embedding import EmbeddingModel
from beeai_framework.backend.text_splitter import TextSplitter
from beeai_framework.backend.vector_store import VectorStore
from beeai_framework.memory import UnconstrainedMemory
from beeai_framework.tools.search.wikipedia import WikipediaTool
from beeai_framework.tools.weather import OpenMeteoTool
from beeai_framework.tools.search.retrieval import VectorStoreSearchTool

async def main():
    # Step 1: Load and process your documents
    loader = DocumentLoader.from_name(
        "langchain:UnstructuredMarkdownLoader", 
        file_path="docs/modules/agents.mdx"  # Replace with your file path
    )
    text_splitter = TextSplitter.from_name(
        "langchain:RecursiveCharacterTextSplitter", 
        chunk_size=1000, 
        chunk_overlap=200
    )
    embedding_model = EmbeddingModel.from_name(
        "watsonx:ibm/slate-125m-english-rtrvr-v2", 
        truncate_input_tokens=500
    )

    # Step 2: Create a vector store and populate it
    vector_store = VectorStore.from_name(
        "beeai:TemporalVectorStore", 
        embedding_model=embedding_model
    )

    # Load your documents
    try:
        documents = await loader.load()
        chunks = await text_splitter.split_documents(documents)
        await vector_store.add_documents(chunks)
        print(f"Loaded {len(chunks)} document chunks")
    except Exception as e:
        print(f"Failed to load documents: {e}")
        return

    # Step 3: Add RAG capability to your agent
    rag_tool = VectorStoreSearchTool(vector_store=vector_store)

    agent = RequirementAgent(
        llm=ChatModel.from_name("ollama:granite3.3:8b"),
        memory=UnconstrainedMemory(),
        tools=[WikipediaTool(), OpenMeteoTool(), rag_tool],  # Now includes document search
        role="Knowledge Assistant",
        instructions="""You are a knowledgeable assistant with access to:
        1. A document knowledge base (use VectorStoreSearch for specific document queries)
        2. Wikipedia for general facts
        3. Weather information
        
        When users ask about topics that might be in the documents, search your knowledge base first."""
    )
    
    response = await agent.run("What types of agents are available in BeeAI?")
    print(response.answer.text)

if __name__ == "__main__":
    asyncio.run(main())
```

1. Add some markdown files with information about your company/project
2. Ask questions that should be answered from your documents
3. Compare how responses differ with vs. without the knowledge base

<Note>
Install the RAG extras if you haven't already: `pip install 'beeai-framework[rag]'`
</Note>

## Orchestration: Agent Coordination

<Info>
New Module: [Workflows](https://framework.beeai.dev/modules/workflows)
</Info>

### Multi-Agent Hand-offs

Create a team of specialized agents that can collaborate:

```Python
import asyncio
from beeai_framework.agents.experimental import RequirementAgent
from beeai_framework.backend import ChatModel
from beeai_framework.memory import UnconstrainedMemory
from beeai_framework.tools.search.wikipedia import WikipediaTool
from beeai_framework.tools.weather import OpenMeteoTool
from beeai_framework.tools.handoff import HandoffTool
from beeai_framework.tools.think import ThinkTool

async def main():
    # Create specialized agents
    knowledge_agent = RequirementAgent(
        llm=ChatModel.from_name("ollama:granite3.3:8b"),
        tools=[ThinkTool(), WikipediaTool()],
        memory=UnconstrainedMemory(),
        role="Knowledge Specialist", 
        instructions="Provide detailed, accurate information using available knowledge sources. Think through problems step by step."
    )

    weather_agent = RequirementAgent(
        llm=ChatModel.from_name("ollama:granite3.3:8b"),
        tools=[ThinkTool(), OpenMeteoTool()],
        memory=UnconstrainedMemory(),
        role="Weather Expert",
        instructions="Provide comprehensive weather information and forecasts. Always think before using tools."
    )

    # Create a coordinator agent that manages handoffs
    coordinator_agent = RequirementAgent(
        llm=ChatModel.from_name("ollama:granite3.3:8b"),
        memory=UnconstrainedMemory(),
        tools=[
            HandoffTool(
                target=knowledge_agent, 
                name="knowledge_specialist", 
                description="For general knowledge and research questions"
            ),
            HandoffTool(
                target=weather_agent, 
                name="weather_expert", 
                description="For weather-related queries"
            ),
        ],
        role="Coordinator",
        instructions="""You coordinate between specialist agents. 
        - For weather queries: use weather_expert
        - For research/knowledge questions: use knowledge_specialist  
        - For mixed queries: break them down and use multiple specialists
        
        Always introduce yourself and explain which specialist will help."""
    )
    
    response = await coordinator_agent.run("What's the weather in Paris and tell me about its history?")
    print(response.answer.text)

if __name__ == "__main__":
    asyncio.run(main())
```

1. Ask the coordinator mixed questions: "What's the weather in Paris and tell me about its history?"
2. Test how it decides which agent to use
3. Try complex queries that need multiple specialists

### Advanced Workflow System

For complex, multi-step processes, use the Workflow system:

```Python
import asyncio
from beeai_framework.backend import ChatModel
from beeai_framework.tools.search.wikipedia import WikipediaTool
from beeai_framework.tools.weather import OpenMeteoTool
from beeai_framework.workflows.agent import AgentWorkflow

async def main():
    # Create a workflow that coordinates multiple agents
    workflow = AgentWorkflow(name="Research Team")
    llm = ChatModel.from_name("ollama:granite3.3:8b")

    # Add specialized agents to the workflow
    workflow.add_agent({
        "name": "Researcher",
        "role": "A diligent researcher",
        "instructions": "You look up and provide information about specific topics.",
        "tools": [WikipediaTool()],
        "llm": llm,
    })

    workflow.add_agent({
        "name": "WeatherExpert", 
        "role": "A weather reporter",
        "instructions": "You provide detailed weather reports.",
        "tools": [OpenMeteoTool()],
        "llm": llm,
    })

    workflow.add_agent({
        "name": "Synthesizer",
        "role": "A data synthesizer", 
        "instructions": "You combine information into coherent summaries.",
        "llm": llm,
    })

    # Run the workflow with multiple tasks
    result = await workflow.run([
        {
            "prompt": "Provide a short history of Paris"
        },
        {
            "prompt": "Get the current weather for Paris"
        },
        {
            "prompt": "Combine the history and weather into a travel brief"
        }
    ])
    
    print(result.state.final_answer)

if __name__ == "__main__":
    asyncio.run(main())
```

---

## Production: Scale & Monitor

### Monitoring & Logging

<Info>
New Modules: [Observability](https://framework.beeai.dev/modules/observability), [Logger](https://framework.beeai.dev/modules/logger), [Events](https://framework.beeai.dev/modules/events), [Emitter](https://framework.beeai.dev/modules/emitter)
</Info>

Monitor and log your agents' behavior with events, emitters, and structured logging:

```Python
import asyncio
import logging
from typing import Any
from beeai_framework.agents.experimental import RequirementAgent
from beeai_framework.backend import ChatModel
from beeai_framework.memory import UnconstrainedMemory
from beeai_framework.tools.search.wikipedia import WikipediaTool
from beeai_framework.tools.weather import OpenMeteoTool
from beeai_framework.middleware.trajectory import GlobalTrajectoryMiddleware
from beeai_framework.logger import Logger
from beeai_framework.emitter import EventMeta
from beeai_framework.tools import Tool

async def main():
    # Set up structured logging
    logger = Logger("production_agent", level=logging.INFO)
    
    def log_agent_events(data: Any, event: EventMeta) -> None:
        """Custom event handler for monitoring agent behavior"""
        
        # Log different event types appropriately
        if event.name == "start":
            if hasattr(data, 'step'):
                logger.info(f"🚀 Starting step: {data.step}")
            else:
                logger.info("🤖 Agent execution started")
                
        elif event.name == "success":
            if hasattr(data, 'output'):
                logger.info(f"✅ Tool succeeded: {event.creator.__class__.__name__}")
                logger.debug(f"Tool output: {data.output.get_text_content()[:200]}...")
            else:
                logger.info("✅ Agent execution completed successfully")
                
        elif event.name == "error":
            logger.error(f"❌ Error in {event.creator.__class__.__name__}: {data}")
            
        elif event.name == "retry":
            logger.warning(f"🔄 Retrying operation in {event.creator.__class__.__name__}")
            
        # Log tool-specific events
        if isinstance(event.creator, Tool):
            logger.debug(f"🔧 Tool event: {event.path} - {event.name}")

    agent = RequirementAgent(
        llm=ChatModel.from_name("ollama:granite3.3:8b"),
        memory=UnconstrainedMemory(),
        tools=[WikipediaTool(), OpenMeteoTool()],
        role="Production Assistant",
        instructions="You are a production assistant with comprehensive monitoring and logging.",
        middlewares=[GlobalTrajectoryMiddleware(included=[Tool])]
    )

    logger.info("🚀 Starting monitored agent conversation")
    
    # Use the observe method to attach event monitoring
    response = await agent.run(
        "Compare the weather in Tokyo and New York, then tell me about the relationship between these cities"
    ).observe(lambda emitter: emitter.match("*.*", log_agent_events))
    
    logger.info("📋 Final response generated")
    logger.debug(f"Response length: {len(response.answer.text)} characters")
    
    print("\n" + "="*60)
    print("🤖 AGENT RESPONSE:")
    print("="*60)
    print(response.answer.text)

if __name__ == "__main__":
    asyncio.run(main())
```

### Intelligent Caching System

<Info>
New Module: [Cache](https://framework.beeai.dev/modules/cache)
</Info>

Speed up responses and reduce costs with smart caching:

```Python
import asyncio
from beeai_framework.agents.experimental import RequirementAgent
from beeai_framework.backend import ChatModel
from beeai_framework.memory import UnconstrainedMemory
from beeai_framework.tools.weather import OpenMeteoTool
from beeai_framework.cache import UnconstrainedCache

async def main():
    # Create a cached weather tool to avoid repeated API calls
    weather_tool = OpenMeteoTool()
    weather_tool.cache = UnconstrainedCache()
    
    agent = RequirementAgent(
        llm=ChatModel.from_name("ollama:granite3.3:8b"),
        memory=UnconstrainedMemory(),
        tools=[weather_tool],
        role="Weather Assistant",
        instructions="You provide weather information efficiently."
    )

    # First call will hit the API
    response1 = await agent.run("What's the weather in New York?")
    print("First call:", response1.answer.text)
    
    # Second call will use cached result
    response2 = await agent.run("What's the weather in New York?")
    print("Cached call:", response2.answer.text)

if __name__ == "__main__":
    asyncio.run(main())
```

### Production Error Handling

<Info>
New Module: [Errors](https://framework.beeai.dev/modules/errors)
</Info>

Make your system robust with comprehensive error management:

```Python
import asyncio
import traceback
from beeai_framework.agents.experimental import RequirementAgent
from beeai_framework.backend import ChatModel
from beeai_framework.memory import UnconstrainedMemory
from beeai_framework.tools.weather import OpenMeteoTool
from beeai_framework.errors import FrameworkError

async def main():
    try:
        agent = RequirementAgent(
            llm=ChatModel.from_name("ollama:granite3.3:8b"),
            memory=UnconstrainedMemory(),
            tools=[OpenMeteoTool()],
            role="Weather Assistant",
            instructions="You provide weather information."
        )

        response = await agent.run("What's the weather in Invalid-City-Name?")
        print(response.answer.text)
        
    except FrameworkError as e:
        print(f"Framework error occurred: {e.explain()}")
        traceback.print_exc()
    except Exception as e:
        print(f"Unexpected error: {e}")
        traceback.print_exc()

if __name__ == "__main__":
    asyncio.run(main())
```

### State Persistence & Serialization

<Info>
New Module: [Serialization](https://framework.beeai.dev/modules/serialization)
</Info>

Save and restore your agent's state for production continuity:

```Python
import asyncio
import json
from beeai_framework.agents.experimental import RequirementAgent
from beeai_framework.backend import ChatModel
from beeai_framework.memory import UnconstrainedMemory

async def main():
    agent = RequirementAgent(
        llm=ChatModel.from_name("ollama:granite3.3:8b"),
        memory=UnconstrainedMemory(),
        role="Persistent Assistant",
        instructions="You remember our conversations."
    )

    # Have a conversation
    response1 = await agent.run("My favorite color is blue")
    print("Agent:", response1.answer.text)
    
    # Save the agent's memory state
    memory_state = agent.memory.create_snapshot()
    with open("agent_memory.json", "w") as f:
        json.dump({
            "messages": [msg.model_dump() for msg in memory_state["messages"]]
        }, f)
    print("Memory saved!")
    
    # Create a new agent and restore memory
    new_agent = RequirementAgent(
        llm=ChatModel.from_name("ollama:granite3.3:8b"),
        memory=UnconstrainedMemory(),
        role="Persistent Assistant",
        instructions="You remember our conversations."
    )
    
    # Load and restore memory (simplified example)
    with open("agent_memory.json", "r") as f:
        saved_data = json.load(f)
    
    # In practice, you'd properly deserialize the messages
    response2 = await new_agent.run("What's my favorite color?")
    print("New agent:", response2.answer.text)

if __name__ == "__main__":
    asyncio.run(main())
```

---

## Integration: Connect & Serve

<Info>
New Module: [Serve](https://framework.beeai.dev/modules/serve)
</Info>

<Tabs>
  <Tab title="MCP Server">
    Expose your agent as an MCP server:
    
    ```python
    from beeai_framework.adapters.mcp import MCPServer
    from beeai_framework.tools.weather import OpenMeteoTool
    from beeai_framework.tools.search.wikipedia import WikipediaTool

    def main():
        # Create an MCP server
        server = MCPServer()
        
        # Register tools that can be used by MCP clients
        server.register_many([
            OpenMeteoTool(),
            WikipediaTool()
        ])
        
        # Start the server
        server.serve()

    if __name__ == "__main__":
        main()
    ```
  </Tab>
  <Tab title="BeeAI Platform Server">
    Expose your agent as a BeeAI Platform server:
    
    ```python
    from beeai_framework.adapters.beeai_platform.serve.server import BeeAIPlatformServer
    from beeai_framework.agents.experimental import RequirementAgent
    from beeai_framework.backend import ChatModel
    from beeai_framework.memory import UnconstrainedMemory
    from beeai_framework.middleware.trajectory import GlobalTrajectoryMiddleware
    from beeai_framework.tools.search.wikipedia import WikipediaTool
    from beeai_framework.tools.weather import OpenMeteoTool

    def main():
        llm = ChatModel.from_name("ollama:granite3.3:8b")
        agent = RequirementAgent(
            llm=llm,
            tools=[WikipediaTool(), OpenMeteoTool()],
            memory=UnconstrainedMemory(),
            middlewares=[GlobalTrajectoryMiddleware()],
            role="Research Assistant",
            instructions="You are a helpful research assistant with access to Wikipedia and weather data."
        )

        # Runs HTTP server that registers to BeeAI platform
        server = BeeAIPlatformServer()
        server.register()
        server.serve()

    if __name__ == "__main__":
        main()
    ```
  </Tab>
  <Tab title="A2A Server">
    Expose your agent as an A2A server:
    
    ```python
    from beeai_framework.adapters.a2a import A2AServer, A2AServerConfig
    from beeai_framework.agents.experimental import RequirementAgent
    from beeai_framework.backend import ChatModel
    from beeai_framework.memory import UnconstrainedMemory
    from beeai_framework.serve.utils import LRUMemoryManager
    from beeai_framework.tools.search.duckduckgo import DuckDuckGoSearchTool
    from beeai_framework.tools.weather import OpenMeteoTool


    def main() -> None:
        llm = ChatModel.from_name("ollama:granite3.3:8b")
        agent = RequirementAgent(
            llm=llm,
            tools=[DuckDuckGoSearchTool(), OpenMeteoTool()],
            memory=UnconstrainedMemory(),
        )

        # Register the agent with the A2A server and run the HTTP server
        # For the ToolCallingAgent, we don't need to specify ACPAgent factory method
        # because it is already registered in the A2AServer
        # we use LRU memory manager to keep limited amount of sessions in the memory
        A2AServer(config=A2AServerConfig(port=9999), memory_manager=LRUMemoryManager(maxsize=100)).register(agent).serve()


    if __name__ == "__main__":
        main()
    ```
  </Tab>
  <Tab title="IBM wxO Server">
    Expose your agent as an IBM watsonx Orchestrate server:
    
    ```python
    from beeai_framework.adapters.watsonx_orchestrate import WatsonxOrchestrateServer, WatsonxOrchestrateServerConfig
    from beeai_framework.agents.experimental import RequirementAgent
    from beeai_framework.backend import ChatModel
    from beeai_framework.memory import UnconstrainedMemory
    from beeai_framework.serve.utils import LRUMemoryManager
    from beeai_framework.tools.weather import OpenMeteoTool


    def main() -> None:
        llm = ChatModel.from_name("ollama:granite3.3:8b")
        agent = RequirementAgent(llm=llm, tools=[OpenMeteoTool()], memory=UnconstrainedMemory(), role="a weather agent")

        config = WatsonxOrchestrateServerConfig(port=8080, host="0.0.0.0", api_key=None)  # optional
        # use LRU memory manager to keep limited amount of sessions in the memory
        server = WatsonxOrchestrateServer(config=config, memory_manager=LRUMemoryManager(maxsize=100))
        server.register(agent)

        # start an API with /chat/completions endpoint which is compatible with Watsonx Orchestrate
        server.serve()


    if __name__ == "__main__":
        main()
    ```
  </Tab>
</Tabs>

---

## What's Next?

Congratulations! You've built a complete AI agent system from a simple chat bot to a production-ready, multi-agent workflow with knowledge bases, caching, monitoring, and service endpoints.

Each module page includes detailed guides, examples, and best practices. Here are some next steps:
1. **Explore Advanced Features:** Dive deeper into specific modules that interest you
2. **Scale Your System:** Add more agents, tools, and knowledge bases
3. **Custom Tools:** Build your own tools for domain-specific functionality

The framework is designed to scale with you—start small, then grow your system step by step as your needs evolve.